الاسم : شذى طلال الحسين ,,
الفئة الثالثة 


///////////////////////////////////توصيف مسألة البحث //////////////////////////////////////////////

البرنامج عبارة عن لعبة منطقية تدعى (Logic Magnets )مصممة باستخدام مكتبة (Tkinter) في بايثون .
تتكون الرقعة من شبكة مربعة بابعاد (n×n)حيث تحتوي على خلايا اما فارغة او تحتوي على قطع ملونة , يوجد بعض الخلايا ملونة بالاخضر ,
 الهدف من اللعبة هو تحريك القطع بحيث يتم وضعها جميعها على الخلايا الخضراء

-تفاصيل اللعبة :
القطع الحمراء تجذب القطع الرمادية والبنفسجية اليها عند تحريكها 
القطع البنفسجية تنفر القطع الرمادية والحمراء منها عند تحريكها
الخلايا الخضراء تمثل الاهداف التي يجب وضع القطع عليها 
يتم البحث عن الحل من خلال خوارزميتي BFS , DFS
يتم الحل من قبل البرنامج تلقائيا عند اختيار احدى الخوارزميتين ويعرض الحل بشكل متحرك مع اظهار الانتقالات 


1-توصيف الحالات :
يتم تمثيل الحالة من خلال ترتيب القطع المختلفة على الرقعة بشكل عشوائي من خلال الدالة create_board()
بالاضافة الى تحديد الخلايا الفارغة وموقعها وكل حالة يتم تمثيلها على هيئة حالة مشفرة تتضمن ترتيب القطع ومواقعها والخلايا الفارغة 
colors = ["gray", "purple", "red", "green"] مصفوفة لتمثيل الالوان المستخدمة في الرقعة 
empty_cells = [] مصفوفة تحتوي على مواقع جميع الخلايا الفارغة في الرقعة
pieces = {} قاموس لتخزين القطع الملونة ومواقعها  بحيث المفتاح هو موقع القطعة على الرقعة والقيمة هي لون القطعة 
green_cells = [] مصفوفة تحتوي على مواقع جميع الخلايا الخضراء(الاهداف)
active_piece متغير لتتبع القطع النشطة المراد تحريكها 
class Node لتمثيل الحالة في كل لحظة يحتوي على دالتين : 
__init__(self, state, parent=None, action=None) وهي لتمثيل الحالة بكل لحظة 
get_path(self) دالة لاعادة مسار الحل من البداية الى النهاية (يعيد مسار الحل الذي اتبعته الخوارزمية في وذلك بعد الوصول الى الهدف )
يتم تمثيل الحالة على هيئة حالة مشفرة لكي نتمكن من تخزينها ومقارنتها في كل مرة اثناء محاولة الوصول للهدف من خلال الدالتين 
encode_state(pieces, empty_cells) يقوم بالتشفير والترتيب بحسب المواقع في tuple
decode_state(state) يقوم باعادة الحالة المشفرة الى الحالة الاصلية 

2- فضاء الحالات :

هو جميع الترتيبات الممكنة للقطع على اللرقعة , يضم فضاء الحالات كل حالة يمكن ان تصل اليها القطع نتيجة تطبيق مجموعة من التحركات من خلال الدالة generate_possible_states(state)
نقوم بارسال الحالة الحالية للدالة وتقوم الدالة بتوليد جميع الحالات الممكنة التالية انطلاقا من الحالة الحالية 
وترجع الدالة قائمة تحتوي على الحالات الجديدة الناتجة عن جميع التحركات الممكنة للقطع في اللعبة 
حجم فضاء الحالات يعتمد على عدد القطع ,حجم الرقعة , التفاعلات بين القطع 

3- الحالة الابتدائية :

هي التوزيع الاولي للقطع على الرقعة قبل القيام بأي حركة (Action) 
يتم انشاء الحالة الابتدائية بشكل عشوائي في بداية اللعبة مع وضع القطع والخلايا الخضراء من خلال الدالةcreate_board() 

4- العمليات والاجراءات :

يتم فقط تحريك القطع الحمراء البنفسجية اما الرمادية لايمكن تحريكها بشكل مباشر وانما فقط تتحرك من خلال الجذب والتنافر 
يتم اختيار احدى القطع الحمراء او البنفسجية من خلال الدالة select_piece(event, row, col)
يتم فحص امكانية تحريك القطعة الى خلية من خلال الدالة move_to_empty_cell(event, target_row, target_col)
تقوم الدالة بالتحقق فيما اذا كانت الخلية المراد النقل اليها فارغة 
تقوم الدالة بفحص لون القطعة واستدعاء الدوال المناسبة للتحريك 
اذا كانت القطعة حمراء يتم استدعاء الدالة attract_pieces_in_state(row, col, pieces, empty_cells)
لجذب القطع التي في سطرها او عمودها والتي بدورها تستدعي الدالة move_piece_towards_in_state(from_row, from_col, to_row, to_col, pieces, empty_cells)
لتقريب جميع القطع بمقدار خطوة واحدة من القطعة الحمراء
اذا كانت القطعة بنفسجية يتم استدعاء الدالة repel_pieces_in_state(row, col, pieces, empty_cells)
لنفر القطع التي في سطرها اة عمودها والتي بدورها تستدعي الدالة move_piece_away_in_state(from_row, from_col, away_row, away_col, pieces, empty_cells)
لابعاد جميع القطع بمقدار خطوة واحدة عن القطعة البنفسجية 
عند كل تحريك يتم التحقق فيما اذا كانت الحالة الحالية تمثل الهدف اذا كانت حالة الهدف يظهر رسالة بالفوز 
اذا لم تكن تمثل حالة هدف يتم توليدالحالات الجديدة الممكنة من خلال generate_possible_states(state) 
ويتم رسم شكل الرقعة الجديدة من خلال الدالة draw_board()

5- الحالة النهائية :

تمثل الحالة النهائية بأنه عندما تكون جميع الخلايا الخضراء تحتوي على قطع 
تم وضع شرط بحيث يكون عدد الخلايا الخضراء في الرقعة مساويا لمجموع القطع الحمراء والبنفسجية والرمادية للتأكد بانه لن يوجد حالة ان تكون خلية خضراء لاتحتوي على قطعة بداخها ودخول البرنامج بحلقة ولا يتمكن من الوصول للهدف او يوجد قطع خارج الخلايا الخضراء 


6- خوارزمية BFS :

بنية القواعد المستخدمة للتخزين والبحث هي qeueu
مبدأ العمل :
bfs(start_state) تبدأ الدالة بادراج الحالة الابتدائية في (qeueu)
على شكل عقدة هذه العقدة تمثل بداية الحل 
يتم استخدام بنية المعطيات set(visited) لتتبع الحالات التي تم زيارتها سابقا وذلك لمنع اعادة زيارة نفس الحالة 
يتم البحث في (qeueu) باستخدام حلقة while  لمعالجة كل عقدة  في القائمة 
في كل خطوة يتم استخراج اول عقدة من القائمة (current_node = queue.popleft())
هذه العقدة تمثل الحالة الحالية التي تتم معالجتها 
يتم التحقق من الوصول للهدف في كل خطوة حيث  بعد استخراج العقدة الحالية، يتم التحقق مما إذا كانت الحالة الحالية تمثل حالة الهدف (goal state) باستخدام الدالة is_goal_state(current_node.state)
إذا كانت الحالة الحالية تمثل الهدف، يتم بناء المسار (تم الوصول للهدف) من خلال استدعاء الدالة current_node.get_path() التي تعيد سلسلة من الحالات وصولاً إلى الهدف
إذا لم تكن الحالة الحالية هي الهدف، يتم توليد جميع الحالات الممكنة التالية انطلاقًا من الحالة الحالية باستخدام الدالة generate_possible_states(current_node.state)
نقوم باضافة الحالات الجديدة الى الqeueu حيث لكل حالة جديدة، إذا لم تكن قد زارت من قبل (new_state not in visited) يتم :
إضافتها إلى المجموعة visited لمنع زيارتها مرة أخرى في المستقبل
إدراجها في قائمة الانتظار على شكل عقدة جديدة (queue.append(Node(new_state, parent=current_node))). الربط مع العقدة الأصلية يتيح تتبع المسار من الحالة الابتدائية إلى الحالة الحالية
تستمر الحلقة حتى يتم العثور على حل (الوصول للهدف ) أو حتى يتم معالجة جميع الحالات الممكنة (نفاد الحالات في قائمة الانتظار)


7- خوارزمية DFS :

بنية القواعد المستخدمة للتخزين والبحث هي stack
مبدأ العمل :
dfs(start_state) تبدأ الدالة بادراج الحالة الابتدائية في (stack)
على شكل عقدة هذه العقدة تمثل بداية الحل 
يتم استخدام بنية المعطيات set(visited) لتتبع الحالات التي تم زيارتها سابقا وذلك لمنع اعادة معالجة نفس الحالة 
يتم البحث في (stack) باستخدام حلقة while  لمعالجة كل عقدة  في المكدس 
في كل خطوة، يتم استخراج آخر عقدة من المكدس (current_node = stack.pop())
بعد استخراج العقدة الحالية، يتم التحقق مما إذا كانت الحالة الحالية هي حالة الهدف (goal state) باستخدام الدالة is_goal_state(current_node.state).
إذا كانت الحالة الحالية تمثل الهدف، يتم بناء وإرجاع المسار (تم الوصول للهدف) من خلال استدعاء current_node.get_path() الذي يعيد التسلسل الكامل للحالات من الحالة الابتدائية إلى الحالة الحالية
إذا لم تكن الحالة الحالية هي حالة الهدف، يتم توليد جميع الحالات الممكنة التالية انطلاقًا من الحالة الحالية باستخدام الدالة generate_possible_states(current_node.state)
لكل حالة جديدة، إذا لم تكن قد زارت سابقًا (new_state not in visited)، يتم:
إضافتها إلى المجموعة visited لتجنب زيارتها مرة أخرى 
إدراجها في المكدس كعقدة جديدة (stack.append(Node(new_state, parent=current_node)))، مع الاحتفاظ بعلاقة الأبوة لتتبع مسار الحل
تستمر الحلقة حتى يتم العثور على حل (الوصول للهدف) أو حتى يتم معالجة جميع الحالات الممكنة (نفاد الحالات في المكدس).

